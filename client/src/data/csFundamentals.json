[
    {
        "title": "1. Operating Systems",
        "sections": [
            {
                "name": "Basics & System Calls",
                "theory": "Operating System act as an intermediary between user and hardware. \n• Kernel: Core component, manages resources.\n• System Calls: Interface to kernel (Open, Read, Write, Fork).\n• Fork(): Creates a child process. Returns 0 to child, PID to parent.",
                "example": "Code:\nif (fork() == 0) printf('Child');\nelse printf('Parent');\n\nQ: How many processes if fork() called n times?\nA: 2ⁿ processes.",
                "formula": "Total Processes = 2ⁿ (where n is number of fork calls)",
                "shortcut": "• Zombie Process: Finished execution but entry still in process table (Parent hasn't called wait).\n• Orphan Process: Parent died, adopted by init."
            },
            {
                "name": "Process Scheduling Algorithms",
                "theory": "Decides which process runs on CPU.\n• FCFS: First Come First Serve (Convoy Effect).\n• SJF: Shortest Job First (Optimal avg waiting time, but starvation).\n• SRTF: Shortest Remaining Time First (Preemptive SJF).\n• Round Robin: Time Quantum based (Fairness).",
                "example": "Scenario: P1(Burst=10), P2(Burst=5). FCFS Order: P1, P2. \nAvg Waiting = (0 + 10)/2 = 5.\nSJF Order: P2, P1. \nAvg Waiting = (0 + 5)/2 = 2.5.",
                "formula": "Turnaround Time (TAT) = Completion Time (CT) - Arrival Time (AT)\nWaiting Time (WT) = TAT - Burst Time (BT)",
                "shortcut": "• Preemptive logic involves pausing current process. • Non-preemptive runs until completion/block."
            },
            {
                "name": "Process Synchronization",
                "theory": "Coordinating processes that share data to avoid Race Conditions.\n• Critical Section: Code part accessing shared resource.\n• Mutex: Locking mechanism (Binary).\n• Semaphore: Signaling mechanism (Counting). Operations: Wait(P) and Signal(V).",
                "example": "Producer-Consumer Problem:\nSemaphore Mutex=1, Empty=N, Full=0;\nProducer: P(Empty), P(Mutex) -> Write -> V(Mutex), V(Full).",
                "formula": "Semaphores: S = S - 1 (Wait/P)\nS = S + 1 (Signal/V)",
                "shortcut": "• Race Condition involves timing. • Deadlock involves circular dependency."
            },
            {
                "name": "Deadlocks & Handling",
                "theory": "Deadlock: Processes waiting indefinitely for each other.\n4 Necessary Conditions: Mutual Exclusion, Hold & Wait, No Preemption, Circular Wait.\n\nHandling:\n• Prevention: Break one of 4 conditions.\n• Avoidance: Banker's Algorithm (Check Safe State).\n• Detection & Recovery: Kill process or preempt resource.",
                "example": "Banker's Algo Check:\nIf (Request <= Available) -> Simulate Allocation -> Check if System Safe.",
                "formula": "Available = Available - Request\nAllocation = Allocation + Request\nNeed = Need - Request",
                "shortcut": "• Ostrich Algorithm: Ignore the problem (used by Unix/Windows)."
            },
            {
                "name": "Memory Management (Paging)",
                "theory": "Non-contiguous allocation.\n• Logical Address: Generated by CPU (Page # + Offset).\n• Physical Address: Actual RAM location (Frame # + Offset).\n• Page Table: Maps Page# to Frame#.",
                "example": "Q: Logical Addr = 32 bit, Page Size = 4KB. Size of Page Table?\nAns: 4KB = 2¹² bytes.\nOffset = 12 bits. Page# = 32-12 = 20 bits.\nEntries = 2²⁰ = 1 Million pages.",
                "formula": "PA = (Frame# * PageSize) + Offset\nEMAT = p(ServiceTime) + (1-p)(MemAccess)",
                "shortcut": "• TLB (Translation Lookaside Buffer) speeds up translation. • Internal Fragmentation acts within a page."
            },
            {
                "name": "Virtual Memory & Page Replacement",
                "theory": "Allows execution of processes larger than physical memory using Demand Paging.\nReplacement Algos:\n• FIFO: First In First Out (Belady's Anomaly).\n• LRU: Least Recently Used (Best practical).\n• Optimal: Replace page needed furthest in future.",
                "example": "Ref String: 1, 2, 3, 1 (3 Frames).\nFIFO: 1, 2, 3 stay. Next 1 is Hit.\nLRU: 1, 2, 3 stay. 1 is Hit (becomes most recent).",
                "formula": "Effective Access Time = (1-p) x Memory_Time + p x Page_Fault_Time",
                "shortcut": "• Thrashing: High paging activity, low CPU utilization."
            },
            {
                "name": "Disk Scheduling",
                "theory": "Optimizing I/O seek time.\n• SSTF: Shortest Seek Time First (Potential Starvation).\n• SCAN: Elevator algorithm (End to end).\n• C-SCAN: Circular (Wrap around, treating cylinder as list).",
                "example": "Head at 50, Request 100.\nSSTF will pick closest request to 50 (e.g., 40 or 60) before 100.",
                "formula": "Total Seek Length = Σ |Current Track - Next Request|",
                "shortcut": "• SCAN is biased towards middle tracks. • C-SCAN provides uniform wait time."
            }
        ]
    },
    {
        "title": "2. Computer Networking (Advanced)",
        "sections": [
            {
                "name": "Physical Layer & Performance Formulas",
                "theory": "Basics of data transmission.\n• Transmission Delay (Tt): Time to push bits onto link.\n• Propagation Delay (Tp): Time for signal to travel.\n• Bandwidth-Delay Product: Capacity of the pipe.\n• Nyquist Theorem: Max data rate for noiseless channel.\n• Shannon Capacity: Max data rate for noisy channel.",
                "example": "Q: 10Mbps link, 2000 bits packet. Find Tt.\nA: Tt = L/B = 2000 / (10 * 10^6) = 200 µs.",
                "formula": "Tt = Length / Bandwidth\nTp = Distance / Speed\nThroughput = Transfer Size / Transfer Time\nShannon C = B * log2(1 + S/N)",
                "shortcut": "• Latency = Tt + Tp + Queueing + Processing.\n• Utilization = Tt / (Tt + 2*Tp) (for Stop-and-Wait)."
            },
            {
                "name": "Data Link Control (MAC & Switching)",
                "theory": "Media Access Control and Switching.\n• CSMA/CD: Ethernet method. Detects collisions and backs off (Binary Exponential Backoff).\n• CSMA/CA: WiFi method. Avoids collisions (RTS/CTS).\n• Circuit Switching: Dedicated path (Phone network).\n• Packet Switching: Shared path (Internet).",
                "example": "Min Frame Size in Ethernet:\nTo detect collision, Tt >= 2*Tp.\nL/B >= 2*(D/V).\nEnsures sender is still transmitting when collision signal returns.",
                "formula": "Min Frame Size = 2 * Bandwidth * Propagation Delay",
                "shortcut": "• ALOHA efficiency: Pure = 18.4%, Slotted = 36.8%.\n• Switch breaks collision domains; Router breaks broadcast domains."
            },
            {
                "name": "IPv4 Header Structure & Fragmentation",
                "theory": "IPv4 Header (20-60 Bytes).\nfields:\n• VER (4): IPv4.\n• HLEN (4): Header Length (x4 bytes).\n• ToS (8): Priority.\n• Total Length (16): Max 65535 bytes.\n• ID, Flags (DF, MF), Offset: Fragmentation.\n• TTL (8): Hop limit (prevent loops).\n• Protocol (8): TCP(6), UDP(17), ICMP(1).\n• Checksum (16): Header error check.\n• Src/Dst IP (32 each).",
                "example": "Fragmentation Example:\nPacket 4000B, MTU 1500B.\nFragment 1: 1500B (20B Header + 1480 Data). MF=1, Offset=0.\nFragment 2: 1500B (20B Header + 1480 Data). MF=1, Offset=185.\nFragment 3: 1040B (20B Header + 1020 Data). MF=0, Offset=370.",
                "formula": "Fragment Offset = Data Bytes So Far / 8",
                "shortcut": "• TTL decrements at each router. If 0, packet discarded (ICMP Time Exceeded)."
            },
            {
                "name": "IPv6 Header & Features",
                "theory": "Next Gen IP.\n• 128-bit Address (Hexadecimal).\n• Header: Fixed 40 Bytes (Simpler processing).\n• No Checksum (Relies on L2/L4).\n• No Fragmentation at Routers (Only at source).\n• Extension Headers: Next Header field chains options.",
                "example": "IPv6 Address: 2001:0db8:85a3:0000:0000:8a2e:0370:7334\nCompressed: 2001:db8:85a3::8a2e:370:7334 (:: replaces zeroes once).",
                "formula": "Address Space: 2^128 (approx 3.4 x 10^38 addresses)",
                "shortcut": "• IPv6 uses Neighbor Discovery Protocol (NDP) instead of ARP.\n• Anycast address: One-to-nearest communication."
            },
            {
                "name": "IP Addressing & Subnetting (Deep Dive)",
                "theory": "Classful vs Classless.\n• Class A: 0-127 (/8)\n• Class B: 128-191 (/16)\n• Class C: 192-223 (/24)\n• Loopback: 127.0.0.0/8\n• APIPA: 169.254.x.x",
                "example": "Q: Given 200.1.2.0/24, create 4 subnets.\nBorrowed bits (n)=2 (since 2^2=4).\nNew Mask: /26 (255.255.255.192).\nBlock Size: 256/4 = 64.\nSubnets: 0-63, 64-127, 128-191, 192-255.",
                "formula": "Subnet Mask: Set 'n' network bits to 1.\nWildcard Mask: Inverse of Subnet Mask.",
                "shortcut": "• First Host = Network ID + 1.\n• Last Host = Broadcast ID - 1."
            },
            {
                "name": "Routing Protocols (Advanced)",
                "theory": "Interior vs Exterior Gateway Protocols.\n• IGP: RIP (Distance Vector), OSPF/IS-IS (Link State), EIGRP (Hybrid).\n• EGP: BGP (Path Vector) - Protocol of the Internet.",
                "example": "OSPF works using Dijkstra. It maintains:\n1. Neighbor Table (Hello packets)\n2. Topology Table (LSDB)\n3. Routing Table (Best paths)",
                "formula": "Administrative Distance (AD): Trustworthiness.\nConnected(0) < Static(1) < EIGRP(90) < OSPF(110) < RIP(120)",
                "shortcut": "• BGP prevents loops using AS-PATH attribute.\n• OSPF Area 0 is the backbone."
            },
            {
                "name": "TCP Congestion Control & Timers",
                "theory": "Algorithms to prevent network collapse.\n• Slow Start: Exp growth (CWND * 2).\n• Congestion Avoidance: Linear growth (CWND + 1) after Threshold.\n• Fast Retransmit: 3 Duplicate ACKs -> Retransmit immediately.\n• Fast Recovery: Skip Slow Start.",
                "example": "Tcp Reno features:\nIf Timeout -> CWND=1, Thresh=CWND/2, Start Slow Start.\nIf 3-Dup-ACK -> CWND=CWND/2, Thresh=CWND/2, Start Congestion Avoidance.",
                "formula": "Retransmission Timeout (RTO) = SRTT + 4*RTTVAR",
                "shortcut": "• Nagle's Algorithm: Combine small packets.\n• Clark's Solution: Prevent Silly Window Syndrome."
            },
            {
                "name": "Network Security (Cryptography)",
                "theory": "CIA Triad: Confidentiality, Integrity, Availability.\n• Algorithms: RSA (Factorization), Diffie-Hellman (Discrete Log), AES (Substitution-Permutation).\n• Protocols: IPSec (Tunnel/Transport mode), SSL/TLS (Handshake), Kerberos (Tickets).",
                "example": "Diffie-Hellman Exchange:\nAlice & Bob agree on g, p.\nAlice picks a, sends A = g^a mod p.\nBob picks b, sends B = g^b mod p.\nShared Secret = B^a mod p = A^b mod p.",
                "formula": "RSA: C = M^e mod n, M = C^d mod n",
                "shortcut": "• VPNs use IPSec or SSL.\n• Digital Certs (X.509) bind Identity to Public Key."
            }
        ]
    },
    {
        "title": "3. Database Management Systems (Advanced)",
        "sections": [
            {
                "name": "ER Model & Relational Keys",
                "theory": "Entity-Relationship Model: Blueprint of database.\n• Entity: Real-world object (Rectangle). Weak Entity: Depends on owner (Double Rectangle).\n• Attributes: Simple, Composite, Derived (Dashed Oval), Multivalued (Double Oval).\n• Keys:\n  - Primary Key (PK): Unique & Not Null.\n  - Candidate Key: Minimal Super Key.\n  - Foreign Key (FK): Refers to PK of another table.\n  - Super Key: Any unique combination.",
                "example": "Scenario: Student(ID, Email, CourseID)\nPK: ID.\nCandidate Keys: ID, Email.\nForeign Key: CourseID references Courses(ID).",
                "formula": "Relations for M:N Relationship = 1 separate table required.\nRelations for 1:N = Merge into 'Many' side.",
                "shortcut": "• Weak Entity always has Total Participation (Double Line). • Self-referencing FK used for Hierarchy (e.g., Manager ID)."
            },
            {
                "name": "Normalization (Deep Dive 1NF-BCNF)",
                "theory": "Minimizing redundancy and dependency.\n• 1NF: Atomic attributes.\n• 2NF: 1NF + No Partial Dependency (Non-prime attr depending on part of Candidate Key).\n• 3NF: 2NF + No Transitive Dependency (Non-prime attr depending on another Non-prime).\n• BCNF: Stronger 3NF (LHS of every FD must be Super Key).",
                "example": "Relation R(A, B, C, D) with Keys {AB}.\nFD: A->C. (Partial Dependency? Yes, A is part of AB. Not 2NF).\nFD: C->D. (Transitive? Yes, if AB->C and C->D. Not 3NF).",
                "formula": "Lossless Decomposition: R1 ∩ R2 -> R1 or R2 (Common attr must be key)",
                "shortcut": "• 2NF issue: Composite Primary Key. • 3NF issue: Non-key determining Non-key."
            },
            {
                "name": "SQL Commands & Queries (DDL, DML, TCL)",
                "theory": "• DDL (Structure): CREATE, ALTER, DROP, TRUNCATE.\n• DML (Data): SELECT, INSERT, UPDATE, DELETE.\n• DCL (Access): GRANT, REVOKE.\n• TCL (Transaction): COMMIT, ROLLBACK, SAVEPOINT.",
                "example": "Q: Find 2nd Highest Salary.\nQuery: \nSELECT MAX(Salary) FROM Emp \nWHERE Salary < (SELECT MAX(Salary) FROM Emp);\n\n-- Using Window Func\nSELECT Salary FROM (\n  SELECT Salary, DENSE_RANK() OVER(ORDER BY Salary DESC) as rnk\n  FROM Emp) WHERE rnk=2;",
                "formula": "Order Logic: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY",
                "shortcut": "• TRUNCATE is faster than DELETE (Reset HWM, No Undo logs). • DELETE can have 'WHERE' clause."
            },
            {
                "name": "Joins (Inner, Outer, Self)",
                "theory": "Combining rows from two or more tables.\n• Inner Join: Matching records only.\n• Left (Outer) Join: All from Left + Matching from Right (Null if no match).\n• Right (Outer) Join: All from Right + Matching from Left.\n• Full Join: Everything.\n• Cross Join: Cartesian Product (AxB).",
                "example": "Table A: {1, 2}, Table B: {2, 3}\nInner: {2}\nLeft: {1, 2}\nRight: {2, 3}\nFull: {1, 2, 3}\nCross: {(1,2), (1,3), (2,2), (2,3)}",
                "formula": "Max Rows (Inner) = min(m, n)\nMax Rows (Cross) = m * n",
                "shortcut": "• Self Join is used when comparing rows within the same table (e.g., Employee vs Manager)."
            },
            {
                "name": "Transactions & Concurrency Control",
                "theory": "Managing concurrent access.\n• ACID: Atomicity (All/None), Consistency, Isolation, Durability.\n• Serializability: Conflict Serializability (No cycles in Precedence Graph).\n• Protocols: 2-Phase Locking (2PL), Timestamp Ordering.",
                "example": "Conflict Equivalency Rules:\nSwapping non-conflicting ops (R-R, different items) is fine.\nConflict: R(x)-W(x), W(x)-R(x), W(x)-W(x).",
                "formula": "Thomas Write Rule (Timestamp): Ignored outdated writes.",
                "shortcut": "• Dirty Read: Reading uncommitted data. • Phantom Read: Rows appear/disappear during transaction."
            },
            {
                "name": "Indexing (B-Tree, B+ Tree)",
                "theory": "Data structures for fast retrieval.\n• B-Tree: Internal nodes store keys + data ptrs. (Used in HDD)\n• B+ Tree: Internal nodes only keys. Leaf nodes store all keys + data ptrs + linked list. (Better for Range queries).\n• Clustered vs Non-Clustered Index.",
                "example": "Why B+ Tree for DB?\n1. Higher Fanout (more keys fit in block).\n2. Lower Tree Height (fewer disk I/Os).\n3. Leaf Linked List allows fast sequential access (Range Scans).",
                "formula": "Search Cost: O(log_f N) base 'Fanout'",
                "shortcut": "• Primary Index -> Sparse Index. • Secondary Index -> Dense Index."
            },
            {
                "name": "Hashing (Static & Dynamic)",
                "theory": "Direct access using Hash Function.\n• Static Hashing: Fixed buckets. Issue: Overflow chains.\n• Dynamic (Extendible) Hashing: Directory of pointers. Splitting buckets when full.\n• Linear Hashing: Incremental expansion.",
                "example": "Hash Collision Handling:\n1. Chaining (Linked List)\n2. Open Addressing (Linear/Quadratic Probing)",
                "formula": "Load Factor (α) = Number of Records / Number of Slots",
                "shortcut": "• Hashing is O(1) for Point Queries (Where ID=X) but bad for Range Queries (Where ID > X)."
            }
        ]
    },
    {
        "title": "4. Object-Oriented Programming (Advanced)",
        "sections": [
            {
                "name": "Classes, Objects & Access Specifiers",
                "theory": "Building blocks of OOP.\n• Class: Blueprint/Template.\n• Object: Instance of class.\n• Access Specifiers:\n  - Private: Accessible only within class (Default).\n  - Public: Accessible everywhere.\n  - Protected: Accessible in class & derived classes.",
                "example": "class Hero {\n  private: int health;\n  public: void heal() { health += 10; }\n};",
                "formula": "Size of Empty Class in C++ = 1 Byte (to ensure unique address).",
                "shortcut": "• Struct vs Class: Struct members are Public by default, Class members are Private."
            },
            {
                "name": "Constructors & Destructors (Deep vs Shallow)",
                "theory": "Lifecycle methods.\n• Constructor: Init object. Types: Default, Parameterized, Copy.\n• Shallow Copy: Copies pointers/references (Double free error risks).\n• Deep Copy: Allocates new memory and copies values.\n• Destructor: Cleans up resources (~ClassName).",
                "example": "Copy Constructor:\nClassName(const ClassName &obj) {\n  ptr = new int; \n  *ptr = *obj.ptr; // Deep Copy\n}",
                "formula": "Rule of Three: If you need a Destructor, you likely need Copy Constructor & Copy Assignment Op.",
                "shortcut": "• Virtual Destructor is mandatory in Base class to prevent Memory Leaks in Derived objects."
            },
            {
                "name": "The 4 Pillars (Encap, Inherit, Poly, Abstract)",
                "theory": "• Encapsulation: Data Hiding (Getters/Setters).\n• Inheritance: Reusability (IS-A relationship).\n• Polymorphism: Many forms (Overloading/Overriding).\n• Abstraction: Hiding complexity (Abstract Classes).",
                "example": "Inheritance Types:\n1. Single (A->B)\n2. Multilevel (A->B->C)\n3. Multiple (A,B -> C)\n4. Hierarchical (A -> B, C)\n5. Hybrid (Mixed)",
                "formula": "Total combinations of Access Modifiers in Inheritance = 9 (Public/Private/Protected derivation).",
                "shortcut": "• Composition (HAS-A) is often preferred over Inheritance (IS-A) for loose coupling."
            },
            {
                "name": "Polymorphism (V-Table & Virtual Functions)",
                "theory": "Runtime choices.\n• Logical: Virtual Function overrides Base method.\n• Internal Mechanism: V-Table (Array of fp) & V-Ptr (Pointer to table).\n• Pure Virtual Function: `virtual void fun() = 0;` (Makes class Abstract).",
                "example": "V-Table Logic:\nClass Base { virtual void f1(); };\nClass Derived : Base { void f1(); };\nBase* b = new Derived();\nb->f1(); // Calls Derived::f1() via V-PTR lookup.",
                "formula": "Overloading = Compile Time (Early Binding). Overriding = Run Time (Late Binding).",
                "shortcut": "• Constructors cannot be Virtual. Destructors SHOULD be Virtual."
            },
            {
                "name": "The Diamond Problem & Virtual Inheritance",
                "theory": "Ambiguity in Multiple Inheritance.\nScenario: Class B & C inherit from A. Class D inherits from B & C.\nD has two copies of A's members.\nSolution: Virtual Inheritance (`class B : virtual public A`).",
                "example": "Structure:\n   A\n /   \\\nB     C\n \\   /\n   D\nWithout partial inheritance, D.A is ambiguous.",
                "formula": "Virtual Inheritance ensures only one shared instance of Base class 'A'.",
                "shortcut": "• Use 'scope resolution operator' (::) to manually resolve ambiguity if not using virtual inheritance."
            },
            {
                "name": "Friend Functions & Operator Overloading",
                "theory": "Breaking encapsulation controlledly.\n• Friend Function: External function accessing private members.\n• Operator Overloading: Redefining symbols (+, -, <<) for objects.",
                "example": "Complex Number Addition:\nComplex operator+(Complex const &obj) {\n  return Complex(real + obj.real, img + obj.img);\n}",
                "formula": "Operators that CANNOT be overloaded: .  .*  ::  ?:",
                "shortcut": "• 'friend' keyword is not mutual. If A is friend of B, B is not friend of A automatically."
            },
            {
                "name": "SOLID Principles & Design Patterns",
                "theory": "Writing maintainable code.\n• S: Single Responsibility.\n• O: Open/Closed (Open for extension, closed for mod).\n• L: Liskov Substitution.\n• I: Interface Segregation.\n• D: Dependency Inversion.\n• Singleton Pattern: Only one instance exists.",
                "example": "Singleton Implementation:\nclass Singleton {\n  static Singleton* instance;\n  private: Singleton() {} // Private Constructor\n};",
                "formula": "Good Design = High Cohesion + Low Coupling",
                "shortcut": "• Common Patterns: Factory (Creation), Observer (Events), Strategy (Algorithms)."
            }
        ]
    }
]