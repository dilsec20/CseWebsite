const pool = require('../db');
const f = [{ t: 'Tree', d: 'Easy', n: 'Max Depth Binary Tree', desc: 'Find max depth.', inp: 'Level-order: vals per level.', out: 'Depth.', con: '0≤n≤10^4', si: '3 9 20\n15 7', so: '3', h: [{ i: '1', o: '1' }, { i: '', o: '0' }, { i: '5 1\n2', o: '2' }] }, { t: 'Tree', d: 'Easy', n: 'Invert Binary Tree', desc: 'Invert tree.', inp: 'Level-order vals.', out: 'Inverted level-order.', con: '0≤n≤100', si: '4 2 7 1 3 6 9', so: '4 7 2 9 6 3 1', h: [{ i: '2 1 3', o: '2 3 1' }, { i: '', o: '' }, { i: '1', o: '1' }] }, { t: 'Tree', d: 'Easy', n: 'Symmetric Tree', desc: 'Check symmetric.', inp: 'Level-order.', out: '"true"/"false".', con: '1≤n≤1000', si: '1 2 2 3 4 4 3', so: 'true', h: [{ i: '1 2 2 null 3 null 3', o: 'false' }, { i: '1', o: 'true' }, { i: '1 2 3', o: 'false' }] }, { t: 'Tree', d: 'Easy', n: 'Diameter of Binary Tree', desc: 'Longest path length.', inp: 'Level-order.', out: 'Diameter.', con: '1≤n≤10^4', si: '1 2 3 4 5', so: '3', h: [{ i: '1 2', o: '1' }, { i: '1', o: '0' }, { i: '1 2 3 4 5 null null 6', o: '4' }] }, { t: 'Tree', d: 'Easy', n: 'Balanced Binary Tree', desc: 'Check height-balanced.', inp: 'Level-order.', out: '"true"/"false".', con: '0≤n≤5000', si: '3 9 20 null null 15 7', so: 'true', h: [{ i: '1 2 2 3 3 null null 4 4', o: 'false' }, { i: '', o: 'true' }, { i: '1', o: 'true' }] }, { t: 'Tree', d: 'Medium', n: 'Validate BST', desc: 'Check valid BST.', inp: 'Level-order.', out: '"true"/"false".', con: '1≤n≤10^4', si: '2 1 3', so: 'true', h: [{ i: '5 1 4 null null 3 6', o: 'false' }, { i: '1', o: 'true' }, { i: '2 1 3', o: 'true' }] }, { t: 'Tree', d: 'Medium', n: 'Lowest Common Ancestor', desc: 'Find LCA of two nodes.', inp: 'Line 1: tree. Line 2: p q.', out: 'LCA value.', con: '2≤n≤10^5', si: '6 2 8 0 4 7 9 null null 3 5\n2 8', so: '6', h: [{ i: '6 2 8 0 4 7 9 null null 3 5\n2 4', o: '2' }, { i: '2 1\n2 1', o: '2' }, { i: '1 2\n2 2', o: '2' }] }, { t: 'Tree', d: 'Medium', n: 'Binary Tree Level Order', desc: 'Level order traversal.', inp: 'Level-order.', out: 'Each level on new line.', con: '0≤n≤2000', si: '3 9 20 null null 15 7', so: '3\n9 20\n15 7', h: [{ i: '1', o: '1' }, { i: '', o: '' }, { i: '1 2 3 4 null null 5', o: '1\n2 3\n4 5' }] }, { t: 'Tree', d: 'Medium', n: 'Path Sum II', desc: 'All root-to-leaf paths summing to target.', inp: 'Line 1: tree. Line 2: target.', out: 'Paths (each on line).', con: '0≤n≤5000', si: '5 4 8 11 null 13 4 7 2 null null 5 1\n22', so: '5 4 11 2\n5 8 4 1', h: [{ i: '1 2 3\n5', o: '' }, { i: '1\n1', o: '1' }, { i: '1 2\n1', o: '' }] }, { t: 'Tree', d: 'Medium', n: 'Construct from Preorder Inorder', desc: 'Build tree from pre & in order.', inp: 'Line 1: preorder. Line 2: inorder.', out: 'Level-order.', con: '1≤n≤3000', si: '3 9 20 15 7\n9 3 15 20 7', so: '3 9 20 null null 15 7', h: [{ i: '-1\n-1', o: '-1' }, { i: '1 2\n2 1', o: '1 2' }, { i: '1 2 3\n2 1 3', o: '1 2 3' }] }, { t: 'Tree', d: 'Hard', n: 'Serialize Deserialize Tree', desc: 'Encode & decode tree.', inp: 'Level-order (null for empty).', out: 'Same format.', con: '0≤n≤10^4', si: '1 2 3 null null 4 5', so: '1 2 3 null null 4 5', h: [{ i: '', o: '' }, { i: '1', o: '1' }, { i: '1 2 3 4 5', o: '1 2 3 4 5' }] }, { t: 'Tree', d: 'Hard', n: 'Binary Tree Max Path Sum', desc: 'Max path sum.', inp: 'Level-order.', out: 'Max sum.', con: '1≤n≤3×10^4,-1000≤val≤1000', si: '-10 9 20 null null 15 7', so: '42', h: [{ i: '1 2 3', o: '6' }, { i: '-3', o: '-3' }, { i: '1 -2 -3 1 3 -2 null -1', o: '3' }] }, { t: 'Graph', d: 'Easy', n: 'Find Center of Star', desc: 'Find center node.', inp: 'Edges.', out: 'Center.', con: '3≤n≤10^5', si: '1 2\n2 3\n4 2', so: '2', h: [{ i: '1 2\n5 1\n1 3\n1 4', o: '1' }, { i: '2 3\n3 1', o: '3' }, { i: '1 2\n2 3', o: '2' }] }, { t: 'Graph', d: 'Easy', n: 'Find Town Judge', desc: 'Find judge (trusted by all, trusts none).', inp: 'n. Edges: a trusts b.', out: 'Judge or -1.', con: '1≤n≤1000', si: '2\n1 2', so: '2', h: [{ i: '3\n1 3\n2 3', o: '3' }, { i: '3\n1 3\n2 3\n3 1', o: '-1' }, { i: '1', o: '1' }] }, { t: 'Graph', d: 'Easy', n: 'All Paths Source to Target', desc: 'All paths from 0 to n-1.', inp: 'Adjacency list.', out: 'All paths.', con: '2≤n≤15', si: '1 2\n3\n3\n', so: '0 1 3\n0 2 3', h: [{ i: '1\n', o: '0 1' }, { i: '3\n0\n0\n', o: '0 1 2\n0 2' }, { i: '1 2\n3\n3\n', o: '0 1 3\n0 2 3' }] }, { t: 'Graph', d: 'Easy', n: 'Find if Path Exists', desc: 'Check if path exists.', inp: 'n. Edges. source dest.', out: '"true"/"false".', con: '1≤n≤2×10^5', si: '3\n0 1\n1 2\n2 0\n0\n2', so: 'true', h: [{ i: '6\n0 1\n0 2\n3 5\n5 4\n4 3\n0\n5', o: 'false' }, { i: '1\n\n0\n0', o: 'true' }, { i: '2\n0 1\n0\n1', o: 'true' }] }, { t: 'Graph', d: 'Easy', n: 'Number of Islands', desc: 'Count islands (1=land, 0=water).', inp: 'rows cols. Grid.', out: 'Island count.', con: '1≤m,n≤300', si: '4 5\n11110\n11010\n11000\n00000', so: '1', h: [{ i: '4 5\n11000\n11000\n00100\n00011', o: '3' }, { i: '1 1\n1', o: '1' }, { i: '2 2\n10\n01', o: '2' }] }, { t: 'Graph', d: 'Medium', n: 'Clone Graph', desc: 'Deep copy graph.', inp: 'Adjacency list.', out: 'Same adjacency.', con: '0≤n≤100', si: '1 2\n1 3\n2 4\n3\n', so: '1 2\n1 3\n2 4\n3\n', h: [{ i: '', o: '' }, { i: '1\n', o: '1\n' }, { i: '1 2\n2\n', o: '1 2\n2\n' }] }, { t: 'Graph', d: 'Medium', n: 'Course Schedule', desc: 'Check if can finish courses.', inp: 'numCourses. Prerequisites.', out: '"true"/"false".', con: '1≤n≤2000', si: '2\n1 0', so: 'true', h: [{ i: '2\n1 0\n0 1', o: 'false' }, { i: '1\n', o: 'true' }, { i: '3\n1 0\n2 1', o: 'true' }] }, { t: 'Graph', d: 'Medium', n: 'Number of Provinces', desc: 'Count provinces (connected components).', inp: 'Adjacency matrix.', out: 'Province count.', con: '1≤n≤200', si: '1 1 0\n1 1 0\n0 0 1', so: '2', h: [{ i: '1 0 0\n0 1 0\n0 0 1', o: '3' }, { i: '1', o: '1' }, { i: '1 1\n1 1', o: '1' }] }, { t: 'Graph', d: 'Medium', n: 'Pacific Atlantic Water', desc: 'Cells flowing to both oceans.', inp: 'Matrix.', out: 'Coordinates.', con: '1≤m,n≤200', si: '1 2 2 3 5\n3 2 3 4 4\n2 4 5 3 1\n6 7 1 4 5\n5 1 1 2 4', so: '0 4\n1 3\n1 4\n2 2\n3 0\n3 1\n4 0', h: [{ i: '1', o: '0 0' }, { i: '1 1', o: '0 0' }, { i: '1 2\n3 4', o: '0 0\n0 1' }] }, { t: 'Graph', d: 'Medium', n: 'Network Delay Time', desc: 'Min time for signal to reach all nodes.', inp: 'n k. Edges: u v w.', out: 'Time or -1.', con: '1≤k≤n≤100', si: '4 2\n2 1 1\n2 3 1\n3 4 1', so: '2', h: [{ i: '1 1', o: '0' }, { i: '2 1\n1 2 1', o: '1' }, { i: '2 2\n1 2 1', o: '-1' }] }, { t: 'Graph', d: 'Hard', n: 'Minimum Height Trees', desc: 'Find roots of MHTs.', inp: 'n. Edges.', out: 'Root labels.', con: '1≤n≤2×10^4', si: '4\n1 0\n1 2\n1 3', so: '1', h: [{ i: '6\n3 0\n3 1\n3 2\n3 4\n5 4', o: '3 4' }, { i: '1', o: '0' }, { i: '2\n0 1', o: '0 1' }] }, { t: 'Dynamic Programming', d: 'Easy', n: 'Climbing Stairs', desc: 'Ways to climb n stairs (1 or 2 steps).', inp: 'n', out: 'Ways.', con: '1≤n≤45', si: '3', so: '3', h: [{ i: '2', o: '2' }, { i: '1', o: '1' }, { i: '5', o: '8' }] }, { t: 'Dynamic Programming', d: 'Easy', n: 'Min Cost Climbing', desc: 'Min cost to reach top.', inp: 'Cost array.', out: 'Min cost.', con: '2≤n≤1000', si: '10 15 20', so: '15', h: [{ i: '1 100 1 1 1 100 1 1 100 1', o: '6' }, { i: '10 15', o: '10' }, { i: '1 2 3', o: '2' }] }, { t: 'Dynamic Programming', d: 'Easy', n: 'House Robber', desc: 'Max rob without adjacent.', inp: 'Houses.', out: 'Max amount.', con: '1≤n≤100', si: '1 2 3 1', so: '4', h: [{ i: '2 7 9 3 1', o: '12' }, { i: '1', o: '1' }, { i: '2 1 1 2', o: '4' }] }, { t: 'Dynamic Programming', d: 'Easy', n: 'Maximum Subarray', desc: 'Max subarray sum.', inp: 'Array.', out: 'Max sum.', con: '1≤n≤10^5', si: '-2 1 -3 4 -1 2 1 -5 4', so: '6', h: [{ i: '1', o: '1' }, { i: '-1', o: '-1' }, { i: '5 4 -1 7 8', o: '23' }] }, { t: 'Dynamic Programming', d: 'Easy', n: 'Divisor Game', desc: 'Win divisor game.', inp: 'n', out: '"true"/"false".', con: '1≤n≤1000', si: '2', so: 'true', h: [{ i: '1', o: 'false' }, { i: '3', o: 'false' }, { i: '4', o: 'true' }] }, { t: 'Dynamic Programming', d: 'Medium', n: 'Unique Paths', desc: 'Paths in m×n grid.', inp: 'm n', out: 'Path count.', con: '1≤m,n≤100', si: '3 7', so: '28', h: [{ i: '3 2', o: '3' }, { i: '1 1', o: '1' }, { i: '2 2', o: '2' }] }, { t: 'Dynamic Programming', d: 'Medium', n: 'Coin Change', desc: 'Min coins for amount.', inp: 'Amount. Coins.', out: 'Min coins or -1.', con: '1≤amount≤10^4', si: '11\n1 2 5', so: '3', h: [{ i: '3\n2', o: '-1' }, { i: '0\n1', o: '0' }, { i: '1\n1', o: '1' }] }, { t: 'Dynamic Programming', d: 'Medium', n: 'Longest Increasing Subsequence', desc: 'LIS length.', inp: 'Array.', out: 'Length.', con: '1≤n≤2500', si: '10 9 2 5 3 7 101 18', so: '4', h: [{ i: '0 1 0 3 2 3', o: '4' }, { i: '7 7 7 7', o: '1' }, { i: '1 2 3', o: '3' }] }, { t: 'Dynamic Programming', d: 'Medium', n: 'Word Break', desc: 'Can segment into words.', inp: 'String. Dictionary.', out: '"true"/"false".', con: '1≤s.length≤300', si: 'leetcode\nleet code', so: 'true', h: [{ i: 'applepenapple\napple pen', o: 'true' }, { i: 'catsandog\ncats dog sand and cat', o: 'false' }, { i: 'a\na', o: 'true' }] }, { t: 'Dynamic Programming', d: 'Medium', n: 'Partition Equal Subset', desc: 'Can partition into equal sums.', inp: 'Array.', out: '"true"/"false".', con: '1≤n≤200', si: '1 5 11 5', so: 'true', h: [{ i: '1 2 3 5', o: 'false' }, { i: '2 2', o: 'true' }, { i: '1 2 5', o: 'false' }] }, { t: 'Dynamic Programming', d: 'Hard', n: 'Edit Distance', desc: 'Min ops to convert.', inp: 'word1. word2.', out: 'Min ops.', con: '0≤length≤500', si: 'horse\nros', so: '3', h: [{ i: 'intention\nexecution', o: '5' }, { i: 'a\na', o: '0' }, { i: 'a\nb', o: '1' }] }, { t: 'Dynamic Programming', d: 'Hard', n: 'Regular Expression Match', desc: 'Match with . and *.', inp: 'String. Pattern.', out: '"true"/"false".', con: '1≤s≤20', si: 'aa\na*', so: 'true', h: [{ i: 'aa\na', o: 'false' }, { i: 'ab\n.*', o: 'true' }, { i: 'aab\nc*a*b', o: 'true' }] }, { t: 'Greedy', d: 'Easy', n: 'Assign Cookies', desc: 'Max satisfied children.', inp: 'Line 1: greed. Line 2: sizes.', out: 'Count.', con: '1≤m,n≤3×10^4', si: '1 2 3\n1 1', so: '1', h: [{ i: '1 2\n1 2 3', o: '2' }, { i: '10 9 8 7\n5 6 7 8', o: '2' }, { i: '1 1 1\n1 1 1', o: '3' }] }, { t: 'Greedy', d: 'Easy', n: 'Lemonade Change', desc: 'Can provide change.', inp: 'Bills.', out: '"true"/"false".', con: '1≤n≤10^5', si: '5 5 5 10 20', so: 'true', h: [{ i: '5 5 10 10 20', o: 'false' }, { i: '5 5 10', o: 'true' }, { i: '10 10', o: 'false' }] }, { t: 'Greedy', d: 'Easy', n: 'Best Time Buy Sell II', desc: 'Max profit unlimited transactions.', inp: 'Prices.', out: 'Max profit.', con: '1≤n≤3×10^4', si: '7 1 5 3 6 4', so: '7', h: [{ i: '1 2 3 4 5', o: '4' }, { i: '7 6 4 3 1', o: '0' }, { i: '2 1 2 0 1', o: '2' }] }, { t: 'Greedy', d: 'Easy', n: 'Majority Element', desc: 'Find majority.', inp: 'Array.', out: 'Majority element.', con: '1≤n≤5×10^4', si: '3 2 3', so: '3', h: [{ i: '2 2 1 1 1 2 2', o: '2' }, { i: '1', o: '1' }, { i: '6 5 5', o: '5' }] }, { t: 'Greedy', d: 'Easy', n: 'Minimum Moves Equal', desc: 'Min moves to equal.', inp: 'Array.', out: 'Min moves.', con: '1≤n≤10^5', si: '1 2 3', so: '3', h: [{ i: '1 1 1', o: '0' }, { i: '1 2 3 4 5', o: '6' }, { i: '1 1000000000', o: '999999999' }] }, { t: 'Greedy', d: 'Medium', n: 'Jump Game', desc: 'Can reach last.', inp: 'Array.', out: '"true"/"false".', con: '1≤n≤10^4', si: '2 3 1 1 4', so: 'true', h: [{ i: '3 2 1 0 4', o: 'false' }, { i: '0', o: 'true' }, { i: '2 0 0', o: 'false' }] }, { t: 'Greedy', d: 'Medium', n: 'Gas Station', desc: 'Starting station or -1.', inp: 'Line 1: gas. Line 2: cost.', out: 'Start index.', con: '1≤n≤10^5', si: '1 2 3 4 5\n3 4 5 1 2', so: '3', h: [{ i: '2 3 4\n3 4 3', o: '-1' }, { i: '5\n4', o: '0' }, { i: '1 1\n2 1', o: '1' }] }, { t: 'Greedy', d: 'Medium', n: 'Partition Labels', desc: 'Max partitions with unique chars.', inp: 'String.', out: 'Partition sizes.', con: '1≤length≤500', si: 'ababcbacadefegdehijhklij', so: '9 7 8', h: [{ i: 'eccbbbbdec', o: '10' }, { i: 'a', o: '1' }, { i: 'abcabc', o: '6' }] }, { t: 'Greedy', d: 'Medium', n: 'Queue Reconstruction', desc: 'Reconstruct queue.', inp: 'People: [h,k].', out: 'Reconstructed queue.', con: '1≤n≤2000', si: '7 0\n4 4\n7 1\n5 0\n6 1\n5 2', so: '5 0\n7 0\n5 2\n6 1\n4 4\n7 1', h: [{ i: '6 0\n5 0\n4 0\n3 2\n2 2\n1 4', o: '4 0\n5 0\n2 2\n3 2\n1 4\n6 0' }, { i: '1 0', o: '1 0' }, { i: '2 0\n1 0', o: '1 0\n2 0' }] }, { t: 'Greedy', d: 'Medium', n: 'Non-overlapping Intervals', desc: 'Min removals for non-overlap.', inp: 'Intervals: start end.', out: 'Min removals.', con: '1≤n≤10^5', si: '1 2\n2 3\n3 4\n1 3', so: '1', h: [{ i: '1 2\n1 2\n1 2', o: '2' }, { i: '1 2\n2 3', o: '0' }, { i: '1 100\n11 22\n1 11\n2 12', o: '2' }] }, { t: 'Greedy', d: 'Hard', n: 'Candy', desc: 'Min candies.', inp: 'Ratings.', out: 'Min total.', con: '1≤n≤2×10^4', si: '1 0 2', so: '5', h: [{ i: '1 2 2', o: '4' }, { i: '1 3 2 2 1', o: '7' }, { i: '1', o: '1' }] }, { t: 'Greedy', d: 'Hard', n: 'Jump Game II', desc: 'Min jumps to reach end.', inp: 'Array.', out: 'Min jumps.', con: '1≤n≤10^4', si: '2 3 1 1 4', so: '2', h: [{ i: '2 3 0 1 4', o: '2' }, { i: '1 1 1 1', o: '3' }, { i: '1 2', o: '1' }] }, { t: 'Backtracking', d: 'Easy', n: 'Subsets', desc: 'All subsets.', inp: 'Array.', out: 'All subsets (each on line).', con: '1≤n≤10', si: '1 2 3', so: '\n1\n2\n3\n1 2\n1 3\n2 3\n1 2 3', h: [{ i: '0', o: '\n0' }, { i: '1 2', o: '\n1\n2\n1 2' }, { i: '1', o: '\n1' }] }, { t: 'Backtracking', d: 'Easy', n: 'Letter Case Permutation', desc: 'All case permutations.', inp: 'String.', out: 'All permutations.', con: '1≤length≤12', si: 'a1b2', so: 'a1b2\na1B2\nA1b2\nA1B2', h: [{ i: '3z4', o: '3z4\n3Z4' }, { i: '12345', o: '12345' }, { i: 'C', o: 'c\nC' }] }, { t: 'Backtracking', d: 'Easy', n: 'Combinations', desc: 'All k-length combos from 1..n.', inp: 'n k', out: 'Combos.', con: '1≤k≤n≤20', si: '4 2', so: '1 2\n1 3\n1 4\n2 3\n2 4\n3 4', h: [{ i: '1 1', o: '1' }, { i: '3 3', o: '1 2 3' }, { i: '5 3', o: '1 2 3\n1 2 4\n1 2 5\n1 3 4\n1 3 5\n1 4 5\n2 3 4\n2 3 5\n2 4 5\n3 4 5' }] }, { t: 'Backtracking', d: 'Medium', n: 'Permutations', desc: 'All permutations.', inp: 'Array.', out: 'All perms.', con: '1≤n≤6', si: '1 2 3', so: '1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1', h: [{ i: '0 1', o: '0 1\n1 0' }, { i: '1', o: '1' }, { i: '1 2', o: '1 2\n2 1' }] }, { t: 'Backtracking', d: 'Medium', n: 'Phone Letter Combos', desc: 'Letter combinations.', inp: 'Digits.', out: 'Combos.', con: '0≤digits≤4', si: '23', so: 'ad ae af bd be bf cd ce cf', h: [{ i: '', o: '' }, { i: '2', o: 'a b c' }, { i: '234', o: 'adg adh adi aeg aeh aei afg afh afi bdg bdh bdi beg beh bei bfg bfh bfi cdg cdh cdi ceg ceh cei cfg cfh cfi' }] }, { t: 'Backtracking', d: 'Medium', n: 'Generate Parentheses', desc: 'All valid n-pair parentheses.', inp: 'n', out: 'All combos.', con: '1≤n≤8', si: '3', so: '((()))\n(()())\n(())()\n()(())\n()()()', h: [{ i: '1', o: '()' }, { i: '2', o: '(())\n()()' }, { i: '4', o: '(((())))\n((()()))\n((())())\n((()))()\n(()(()))\n(()()())\n(()())()\n(())(())\n(())()()\n()((()))\n()(()())\n()(())()\n()()(())\n()()()()' }] }, { t: 'Backtracking', d: 'Hard', n: 'N-Queens', desc: 'All solutions.', inp: 'n', out: 'Solutions (boards).', con: '1≤n≤9', si: '4', so: '. Q . .\n. . . Q\nQ . . .\n. . Q .\n\n. . Q .\nQ . . .\n. . . Q\n. Q . .', h: [{ i: '1', o: 'Q' }, { i: '2', o: '' }, { i: '3', o: '' }] }, { t: 'Backtracking', d: 'Hard', n: 'Word Search II', desc: 'Find all words in board.', inp: 'Board. Words.', out: 'Found words.', con: '1≤rows,cols≤12', si: 'o a a n\ne t a e\ni h k r\ni f l v\noath pea eat rain', so: 'eat oath', h: [{ i: 'a b\nc d\nabcd dcba', o: 'abcd dcba' }, { i: 'a\na', o: 'a' }, { i: 'a b\nc d\nab', o: 'ab' }] }]; async function addFinal() { const c = await pool.connect(); try { console.log('Adding final batch...\\n'); let a = 0; for (const p of f) { const e = await c.query('SELECT 1 FROM problems WHERE title=$1', [p.n]); if (e.rows.length) { console.log(`⏭️  ${p.n}`); continue; } const i = await c.query('INSERT INTO problems(title,description,difficulty,topic,input_format,output_format,constraints)VALUES($1,$2,$3,$4,$5,$6,$7)RETURNING problem_id', [p.n, p.desc, p.d, p.t, p.inp, p.out, p.con]); const pid = i.rows[0].problem_id; await c.query('INSERT INTO test_cases(problem_id,input,expected_output,is_sample)VALUES($1,$2,$3,true)', [pid, p.si, p.so]); for (const t of p.h) { await c.query('INSERT INTO test_cases(problem_id,input,expected_output,is_sample)VALUES($1,$2,$3,false)', [pid, t.i, t.o]); } a++; console.log(`✅ ${p.t} ${p.d}: ${p.n}`); } console.log(`\\n✨ Added ${a} in final batch!`); } catch (err) { console.error(err); throw err; } finally { c.release(); await pool.end(); } } addFinal();
